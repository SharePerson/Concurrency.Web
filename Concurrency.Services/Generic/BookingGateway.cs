using AutoMapper;
using Concurrency.Dto;
using Concurrency.Dto.Base;
using Concurrency.Dto.Enums;
using Concurrency.Entities;
using Concurrency.Entities.Banking;
using Concurrency.Services.Interfaces.Generic;
using log4net;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace Concurrency.Services.Generic
{
    /// <summary>
    /// In order for this implementation class to be used, 
    /// the input type AccountDtoDT must inherit from AccountBase as a requirement
    /// and the input type TransactionStatusDT must be an enum
    /// </summary>
    /// <typeparam name="TransactionStatusDT"></typeparam>
    /// <typeparam name="AccountDtoDT"></typeparam>
    public class BookingGateway<TransactionResultDT, AccountDtoDT> : IBookingGateway<TransactionResultDT, AccountDtoDT> where AccountDtoDT : AccountBase where TransactionResultDT : TransactionResult<AccountDtoDT>
    {
        private readonly ConcurrencyDbContext dbContext;
        private readonly IMapper mapper;

        private ILog Log => LogManager.GetLogger(typeof(BookingGateway));

        public BookingGateway(ConcurrencyDbContext dbContext, IMapper mapper)
        {
            this.dbContext = dbContext;
            this.mapper = mapper;
        }

        public async Task<TransactionResultDT> Deposit(AccountDtoDT account, double amount)
        {
            TransactionResult<AccountDtoDT> transactionResult = new()
            {
                Data = account,
                TransferedAmount = amount
            };

            try
            {
                Account accountToUpdate = await dbContext.Accounts.FirstOrDefaultAsync(a => a.Id == account.Id);

                if (accountToUpdate == null)
                {
                    transactionResult.TransactionStatus = TransactionStatus.AccountNotFound;
                    return transactionResult as TransactionResultDT;
                }

                //to include the row version in the update query generated by ef core
                dbContext.Entry(accountToUpdate).Property(nameof(accountToUpdate.RowVersion)).OriginalValue = account.RowVersion;

                DateTime operationDate = DateTime.Now;

                accountToUpdate.Balance += amount;
                accountToUpdate.LastTransactionDate = operationDate;

                dbContext.Accounts.Update(accountToUpdate);

                await dbContext.Transactions.AddAsync(new Transaction
                {
                    Amount = amount,
                    Description = $"Branch visit deposit: +{amount}",
                    Id = Guid.NewGuid(),
                    AccountId = account.Id,
                    TransactionDate = operationDate
                });

                await dbContext.SaveChangesAsync();

                transactionResult.TransactionStatus = TransactionStatus.Success;
                return transactionResult as TransactionResultDT;
            }
            catch (DbUpdateConcurrencyException ex)
            {
                //intended fire and forget
                Task.Run(() => Log.Error(ex.Message, ex));
                transactionResult.IsFaulted = true;

                EntityEntry exEntry = ex.Entries.SingleOrDefault();

                if (exEntry != null)
                {
                    Account clientEntry = exEntry.Entity as Account;

                    if (clientEntry != null)
                    {
                        PropertyValues dbValues = await exEntry.GetDatabaseValuesAsync();

                        if (dbValues == null)
                        {
                            transactionResult.TransactionStatus = TransactionStatus.AccountNotFound;
                            return transactionResult as TransactionResultDT;
                        }

                        Account dbEntry = dbValues.ToObject() as Account;

                        if (dbEntry != null)
                        {
                            if (dbEntry.Balance != clientEntry.Balance)
                            {
                                account.RowVersion = dbEntry.RowVersion;
                                account.Balance = dbEntry.Balance;
                                transactionResult.TransactionStatus = TransactionStatus.OutdatedAccount;
                                return transactionResult as TransactionResultDT;
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                //intended fire and forget
                Task.Run(() => Log.Error(ex.Message, ex));
                transactionResult.IsFaulted = true;
            }

            transactionResult.TransactionStatus = TransactionStatus.Failure;
            return transactionResult as TransactionResultDT;
        }

        public async Task<AccountDtoDT> GetRandomAccount()
        {
            Random rand = new();
            int toSkip = rand.Next(0, 5);
            return mapper.Map<AccountDtoDT>(await dbContext.Accounts.OrderBy(a => a.Id)
                .Skip(toSkip).Take(1)
                .FirstOrDefaultAsync());
        }

        public async Task<TransactionResultDT> Transfer(AccountDtoDT fromAccount, AccountDtoDT toAccount, double amount)
        {
            TransactionResult<AccountDtoDT> transactionResult = new()
            {
                Data = fromAccount,
                TransferedAmount = amount
            };

            if (fromAccount == null || toAccount == null || amount <= 0)
            {
                transactionResult.TransactionStatus = TransactionStatus.BadInput;
                return transactionResult as TransactionResultDT;
            }

            if (fromAccount.Id == toAccount.Id)
            {
                transactionResult.TransactionStatus = TransactionStatus.SameAccountRejection;
                return transactionResult as TransactionResultDT;
            }

            Account fromAccountEntity = await dbContext.Accounts.FirstOrDefaultAsync(a => a.Id == fromAccount.Id);

            if (fromAccountEntity == null)
            {
                transactionResult.TransactionStatus = TransactionStatus.FromAccountNotFound;
                return transactionResult as TransactionResultDT;
            }

            if (fromAccountEntity.Balance < amount)
            {
                transactionResult.TransactionStatus = TransactionStatus.FromAccountInsufficientFunds;
                return transactionResult as TransactionResultDT;
            }

            dbContext.Entry(fromAccountEntity).Property(nameof(fromAccountEntity.RowVersion)).OriginalValue = fromAccount.RowVersion;

            DateTime operationDate = DateTime.Now;

            fromAccountEntity.Balance -= amount;
            fromAccountEntity.LastTransactionDate = operationDate;

            Account toAccountEntity = await dbContext.Accounts.FirstOrDefaultAsync(a => a.Id == toAccount.Id);

            if (toAccountEntity == null)
            {
                transactionResult.TransactionStatus = TransactionStatus.ToAccountNotFound;
                return transactionResult as TransactionResultDT;
            }

            dbContext.Entry(toAccountEntity).Property(nameof(toAccountEntity.RowVersion)).OriginalValue = toAccount.RowVersion;

            toAccountEntity.Balance += amount;
            toAccountEntity.LastTransactionDate = operationDate;

            try
            {
                dbContext.Accounts.Update(fromAccountEntity);
                dbContext.Accounts.Update(toAccountEntity);

                await dbContext.Transactions.AddAsync(new Transaction
                {
                    Amount = -amount,
                    Description = $"Online transfer to {toAccount.AccountHolderName}: -${amount}",
                    Id = Guid.NewGuid(),
                    AccountId = fromAccountEntity.Id,
                    TransactionDate = operationDate
                });

                await dbContext.Transactions.AddAsync(new Transaction
                {
                    Amount = amount,
                    Description = $"Online transfer from {fromAccount.AccountHolderName}: +${amount}",
                    Id = Guid.NewGuid(),
                    AccountId = toAccount.Id,
                    TransactionDate = operationDate
                });

                await dbContext.SaveChangesAsync();

                transactionResult.TransactionStatus = TransactionStatus.Success;
                return transactionResult as TransactionResultDT;
            }
            catch (DbUpdateConcurrencyException ex)
            {
                //intended fire and forget
                Task.Run(() => Log.Error(ex.Message, ex));
                transactionResult.IsFaulted = true;

                EntityEntry exEntry = ex.Entries.SingleOrDefault();

                if (exEntry != null)
                {
                    Account clientEntry = exEntry.Entity as Account;

                    if (clientEntry != null)
                    {
                        PropertyValues dbValues = await exEntry.GetDatabaseValuesAsync();

                        if (clientEntry.Id == fromAccount.Id)
                        {
                            if (dbValues == null)
                            {
                                transactionResult.TransactionStatus = TransactionStatus.FromAccountNotFound;
                                return transactionResult as TransactionResultDT;
                            }

                            Account dbEntry = dbValues.ToObject() as Account;

                            if (dbEntry != null)
                            {
                                if (dbEntry.Balance != clientEntry.Balance)
                                {
                                    fromAccount.RowVersion = dbEntry.RowVersion;
                                    fromAccount.Balance = dbEntry.Balance;

                                    transactionResult.TransactionStatus = TransactionStatus.OutdatedFromAccount;
                                    return transactionResult as TransactionResultDT;
                                }
                            }
                        }

                        if (clientEntry.Id == toAccount.Id)
                        {
                            if (dbValues == null)
                            {
                                transactionResult.TransactionStatus = TransactionStatus.ToAccountNotFound;
                                return transactionResult as TransactionResultDT;
                            }

                            Account dbEntry = dbValues.ToObject() as Account;

                            if (dbEntry != null)
                            {
                                if (dbEntry.Balance != clientEntry.Balance)
                                {
                                    toAccount.RowVersion = dbEntry.RowVersion;
                                    toAccount.Balance = dbEntry.Balance;
                                    transactionResult.TransactionStatus = TransactionStatus.OutdatedToAccount;
                                    return transactionResult as TransactionResultDT;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                //intended fire and forget because Log.Error is synchronous
                Task.Run(() => Log.Error(ex.Message, ex));
                transactionResult.IsFaulted = true;
            }

            transactionResult.TransactionStatus = TransactionStatus.Failure;
            return transactionResult as TransactionResultDT;
        }

        public async Task<TransactionResultDT> Withdraw(AccountDtoDT account, double amount)
        {
            TransactionResult<AccountDtoDT> transactionResult = new()
            {
                Data = account,
                TransferedAmount = amount
            };

            try
            {
                Account accountToUpdate = await dbContext.Accounts.FirstOrDefaultAsync(a => a.Id == account.Id);

                if (accountToUpdate == null)
                {
                    transactionResult.TransactionStatus = TransactionStatus.AccountNotFound;
                    return transactionResult as TransactionResultDT;
                }

                if (accountToUpdate.Balance < amount)
                {
                    transactionResult.TransactionStatus = TransactionStatus.InsufficientFunds;
                    return transactionResult as TransactionResultDT;
                }

                dbContext.Entry(accountToUpdate).Property(nameof(accountToUpdate.RowVersion)).OriginalValue = account.RowVersion;

                DateTime operationDate = DateTime.Now;

                accountToUpdate.Balance -= amount;
                accountToUpdate.LastTransactionDate = operationDate;

                dbContext.Accounts.Update(accountToUpdate);

                await dbContext.Transactions.AddAsync(new Transaction
                {
                    Amount = -amount,
                    Description = $"Branch visit withdraw: -{amount}",
                    Id = Guid.NewGuid(),
                    AccountId = account.Id,
                    TransactionDate = operationDate
                });

                await dbContext.SaveChangesAsync();
                transactionResult.TransactionStatus = TransactionStatus.Success;
                return transactionResult as TransactionResultDT;
            }
            catch (DbUpdateConcurrencyException ex)
            {
                //intended fire and forget
                Task.Run(() => Log.Error(ex.Message, ex));
                transactionResult.IsFaulted = true;

                EntityEntry exEntry = ex.Entries.SingleOrDefault();

                if (exEntry != null)
                {
                    Account clientEntry = exEntry.Entity as Account;

                    if (clientEntry != null)
                    {
                        PropertyValues dbValues = await exEntry.GetDatabaseValuesAsync();

                        if (dbValues == null)
                        {
                            transactionResult.TransactionStatus = TransactionStatus.AccountNotFound;
                            return transactionResult as TransactionResultDT;
                        }

                        Account dbEntry = dbValues.ToObject() as Account;

                        if (dbEntry != null)
                        {
                            if (dbEntry.Balance != clientEntry.Balance)
                            {
                                account.RowVersion = dbEntry.RowVersion;
                                account.Balance = dbEntry.Balance;
                                transactionResult.TransactionStatus = TransactionStatus.OutdatedAccount;
                                return transactionResult as TransactionResultDT;
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                //intended fire and forget
                Task.Run(() => Log.Error(ex.Message, ex));
                transactionResult.IsFaulted = true;
            }

            transactionResult.TransactionStatus = TransactionStatus.Failure;
            return transactionResult as TransactionResultDT;
        }

        public async Task<TransactionResultDT> BookTicket(AccountDtoDT account, TicketDto ticket)
        {
            TransactionResult<AccountDtoDT> transactionResult = new()
            {
                Data = account
            };

            //if any of the inputs is missing then end the process
            if (account == null || ticket == null)
            {
                transactionResult.TransactionStatus = TransactionStatus.BadInput;
                return transactionResult as TransactionResultDT;
            }

            transactionResult.TransferedAmount = ticket.Price;

            try
            {
                Account accountToUpdate = await dbContext.Accounts.FirstOrDefaultAsync(a => a.Id == account.Id);

                //if account is not found in DB for any reason
                if(accountToUpdate == null)
                {
                    transactionResult.TransactionStatus = TransactionStatus.AccountNotFound;
                    return transactionResult as TransactionResultDT;
                }

                Ticket ticketToUpdate = await dbContext.Tickets.FirstOrDefaultAsync(t => t.Id == ticket.Id);

                //if the ticket is not found in DB for any reason
                if(ticketToUpdate == null)
                {
                    transactionResult.TransactionStatus = TransactionStatus.TicketNotFound;
                    return transactionResult as TransactionResultDT;
                }

                //if the ticket is booked by someone else
                if(!ticketToUpdate.IsAvailable)
                {
                    transactionResult.TransactionStatus = TransactionStatus.TicketAlreadyBooked;
                    return transactionResult as TransactionResultDT;
                }

                //if the account does not have a sufficient balance to book the ticket
                if(accountToUpdate.Balance < ticketToUpdate.Price)
                {
                    transactionResult.TransactionStatus = TransactionStatus.InsufficientFunds;
                    return transactionResult as TransactionResultDT;
                }

                //reject the operation if the ticket datetime is in the past or exactly now 
                //since the user will take time to actually use the ticket
                //this should also validate the avg. time taken by the user to actually use the ticket
                if((ticketToUpdate.TicketDate - DateTime.Now).TotalDays <= 1)
                {
                    transactionResult.TransactionStatus = TransactionStatus.TicketDatePassed;
                    return transactionResult as TransactionResultDT;
                }

                //if all the validations above passed, then update EF to include the input RowVersion 
                //value in any subsequent update queries to account for optimistic concurrency
                dbContext.Entry(accountToUpdate).Property(nameof(accountToUpdate.RowVersion)).OriginalValue = account.RowVersion;
                dbContext.Entry(ticketToUpdate).Property(nameof(ticketToUpdate.RowVersion)).OriginalValue = ticket.RowVersion;

                //update the database with the booking as one standalone transaction
                DateTime operationDate = DateTime.Now;

                accountToUpdate.Balance -= ticket.Price;
                accountToUpdate.LastTransactionDate = operationDate;
                ticketToUpdate.IsAvailable = false;
                ticketToUpdate.ReservationDate = operationDate;
                ticketToUpdate.ReservedById = accountToUpdate.Id;

                dbContext.Accounts.Update(accountToUpdate);
                dbContext.Tickets.Update(ticketToUpdate);

                await dbContext.Transactions.AddAsync(new Transaction
                {
                    Amount = -ticket.Price,
                    Description = $"Online booking for ticket {ticketToUpdate.Id}: -${ticketToUpdate.Price}",
                    Id = Guid.NewGuid(),
                    AccountId = account.Id,
                    TransactionDate = operationDate
                });

                await dbContext.SaveChangesAsync();
                transactionResult.TransactionStatus = TransactionStatus.Success;
                return transactionResult as TransactionResultDT;
            }
            catch(DbUpdateConcurrencyException ex)
            {
                transactionResult.IsFaulted = true;
                Task.Run(() => Log.Error(ex.Message, ex));

                EntityEntry exEntry = ex.Entries.SingleOrDefault();

                if(exEntry != null)
                {
                    Account accountClientEntry = exEntry.Entity as Account;

                    PropertyValues dbValues = await exEntry.GetDatabaseValuesAsync();

                    if (accountClientEntry != null)
                    {
                        if (dbValues == null)
                        {
                            transactionResult.TransactionStatus = TransactionStatus.AccountNotFound;
                            return transactionResult as TransactionResultDT;
                        }

                        Account dbEntry = dbValues.ToObject() as Account;

                        if (dbEntry != null)
                        {
                            if (dbEntry.Balance != accountClientEntry.Balance)
                            {
                                account.RowVersion = dbEntry.RowVersion;
                                account.Balance = dbEntry.Balance;
                                account.LastTransactionDate = dbEntry.LastTransactionDate;

                                transactionResult.TransactionStatus = TransactionStatus.OutdatedAccount;
                                return transactionResult as TransactionResultDT;
                            }
                        }
                    }

                    Ticket ticketClientEntry = exEntry.Entity as Ticket;

                    if(ticketClientEntry != null)
                    {
                        if (dbValues == null)
                        {
                            transactionResult.TransactionStatus = TransactionStatus.TicketNotFound;
                            return transactionResult as TransactionResultDT;
                        }

                        Ticket dbEntry = dbValues.ToObject() as Ticket;

                        if (dbEntry != null)
                        {
                            if (dbEntry.Price != ticketClientEntry.Price)
                            {
                                ticket.RowVersion = dbEntry.RowVersion;
                                ticket.Price = dbEntry.Price;
                                ticket.IsAvailable = dbEntry.IsAvailable;
                                ticket.ReservedById = dbEntry.ReservedById;
                                ticket.ReservationDate = dbEntry.ReservationDate;

                                transactionResult.TransactionStatus = TransactionStatus.OutdatedTicket;
                                return transactionResult as TransactionResultDT;
                            }
                        }
                    }
                }
            }
            catch(Exception ex)
            {
                //intended fire and forget
                transactionResult.IsFaulted = true;
                Task.Run(() => Log.Error(ex.Message, ex));
            }

            transactionResult.TransactionStatus = TransactionStatus.Failure;
            return transactionResult as TransactionResultDT;
        }

        public async Task<TransactionResultDT> UnbookTicket(AccountDtoDT account, TicketDto ticket)
        {
            TransactionResult<AccountDtoDT> transactionResult = new()
            {
                Data = account
            };

            if (account == null || ticket == null)
            {
                transactionResult.TransactionStatus = TransactionStatus.BadInput;
                return transactionResult as TransactionResultDT;
            }

            transactionResult.TransferedAmount = ticket.Price;

            try
            {
                Account accountToUpdate = await dbContext.Accounts.FirstOrDefaultAsync(a => a.Id == account.Id);

                //if account is not found in DB for any reason
                if (accountToUpdate == null)
                {
                    transactionResult.TransactionStatus = TransactionStatus.AccountNotFound;
                    return transactionResult as TransactionResultDT;
                }

                Ticket ticketToUpdate = await dbContext.Tickets.FirstOrDefaultAsync(t => t.Id == ticket.Id);

                //if the ticket is not found in DB for any reason
                if (ticketToUpdate == null)
                {
                    transactionResult.TransactionStatus = TransactionStatus.TicketNotFound;
                    return transactionResult as TransactionResultDT;
                }

                //if the ticket is available then it does not make sense to unbook it
                //or if the ticket data was tampered in the db by nulling the ReservedById
                //or if the ticket is not reserved by the input account
                //and consider this a bad input and terminate
                if(ticketToUpdate.IsAvailable || ticket.ReservedById == null || account.Id != ticket.ReservedById)
                {
                    transactionResult.TransactionStatus = TransactionStatus.BadInput;
                    return transactionResult as TransactionResultDT;
                }

                //if the ticket datetime passed, then it is not valid anymore to be available again
                //and the account is not eligible to be refunded
                if((ticketToUpdate.TicketDate - DateTime.Now).TotalDays <= 1)
                {
                    transactionResult.TransactionStatus = TransactionStatus.TicketDatePassed;
                    return transactionResult as TransactionResultDT;
                }

                //if all the validations above passed, then update EF to include the input RowVersion 
                //value in any subsequent update queries to account for optimistic concurrency
                //the ticket to be released is not subject to optimistic concurrency since it's not available to the public
                //we care only about the account against optimistic concurrency
                dbContext.Entry(accountToUpdate).Property(nameof(accountToUpdate.RowVersion)).OriginalValue = account.RowVersion;

                //update the database with the booking as one standalone transaction
                DateTime operationDate = DateTime.Now;

                accountToUpdate.Balance += ticket.Price;
                accountToUpdate.LastTransactionDate = operationDate;
                ticketToUpdate.IsAvailable = true;
                ticketToUpdate.ReservationDate = null;
                ticketToUpdate.ReservedById = null;

                dbContext.Accounts.Update(accountToUpdate);
                dbContext.Tickets.Update(ticketToUpdate);

                await dbContext.Transactions.AddAsync(new Transaction
                {
                    Amount = ticket.Price,
                    Description = $"Refund for online ticket {ticketToUpdate.Id}: +${ticketToUpdate.Price}",
                    Id = Guid.NewGuid(),
                    AccountId = account.Id,
                    TransactionDate = operationDate
                });

                await dbContext.SaveChangesAsync();
                transactionResult.TransactionStatus = TransactionStatus.Success;
                return transactionResult as TransactionResultDT;
            }
            catch(DbUpdateConcurrencyException ex)
            {
                //intended fire and forget
                Task.Run(() => Log.Error(ex.Message, ex));
                transactionResult.IsFaulted = true;

                EntityEntry exEntry = ex.Entries.SingleOrDefault();

                if (exEntry != null)
                {
                    Account clientEntry = exEntry.Entity as Account;

                    if (clientEntry != null)
                    {
                        PropertyValues dbValues = await exEntry.GetDatabaseValuesAsync();

                        if (dbValues == null)
                        {
                            transactionResult.TransactionStatus = TransactionStatus.AccountNotFound;
                            return transactionResult as TransactionResultDT;
                        }

                        Account dbEntry = dbValues.ToObject() as Account;

                        if (dbEntry != null)
                        {
                            if (dbEntry.Balance != clientEntry.Balance)
                            {
                                account.RowVersion = dbEntry.RowVersion;
                                account.Balance = dbEntry.Balance;
                                transactionResult.TransactionStatus = TransactionStatus.OutdatedAccount;
                                return transactionResult as TransactionResultDT;
                            }
                        }
                    }
                }
            }
            catch(Exception ex)
            {
                Task.Run(() => Log.Error(ex.Message, ex));
                transactionResult.IsFaulted = true;
            }

            transactionResult.TransactionStatus = TransactionStatus.Failure;
            return transactionResult as TransactionResultDT;
        }

        public async Task<TicketDto> GetRandomTicket(bool? isAvailable = null)
        {
            Random rand = new();
            IQueryable<Ticket> ticketQuery = null;

            if(isAvailable.HasValue)
            {
                ticketQuery = dbContext.Tickets.Where(t => t.IsAvailable == isAvailable);
            }
            else
            {
                ticketQuery = dbContext.Tickets.AsQueryable();
            }

            int toSkip = rand.Next(0, await ticketQuery.CountAsync());

            Ticket ticketEntity = await ticketQuery.OrderBy(t => t.Id).Skip(toSkip).Take(1).FirstOrDefaultAsync();
            return mapper.Map<TicketDto>(ticketEntity);
        }

        public async Task<AccountDtoDT> GetTicketOwner(Guid ticketId)
        {
            Account accountEntity = await dbContext.Tickets
                .Include(t => t.Account).Where(t => t.Id == ticketId)
                .Select(t => t.Account).FirstOrDefaultAsync();

            return mapper.Map<AccountDtoDT>(accountEntity);
        }

        public async ValueTask DisposeAsync()
        {
            await dbContext.DisposeAsync();
            GC.SuppressFinalize(this);
        }
    }
}
